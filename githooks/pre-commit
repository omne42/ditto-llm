#!/usr/bin/env bash
set -euo pipefail

repo_root="$(git rev-parse --show-toplevel 2>/dev/null || pwd)"

staged_files="$(git diff --cached --name-only --diff-filter=ACMRD || true)"
if [[ -z "${staged_files//[[:space:]]/}" ]]; then
  exit 0
fi

staged_non_deleted_files="$(git diff --cached --name-only --diff-filter=ACMR || true)"
part_name_offenders=()
while IFS= read -r path; do
  [[ -z "$path" ]] && continue
  base="$(basename "$path")"
  if [[ "$base" =~ ^part[0-9]+\.[A-Za-z0-9]+$ ]]; then
    part_name_offenders+=("$path")
  fi
done <<<"$staged_non_deleted_files"

if [[ "${#part_name_offenders[@]}" -gt 0 ]]; then
  cat >&2 <<EOF
pre-commit: refusing to commit files with "partNN" style names.

这类编号分片（例如 part01.rs / part02.rs）是无意义的拆分方式，会掩盖模块边界不清和职责混乱。
请基于清晰的领域边界重新组织代码与命名（例如 auth/config/env/http/...），而不是继续堆叠 partXX。

Offenders:
$(printf '  - %s\n' "${part_name_offenders[@]}")
EOF
  exit 1
fi

has_changelog=0
other_count=0
while IFS= read -r path; do
  [[ -z "$path" ]] && continue
  if [[ "$path" == "CHANGELOG.md" ]]; then
    has_changelog=1
  else
    other_count=$((other_count + 1))
  fi
done <<<"$staged_files"

if [[ "$has_changelog" -ne 1 ]]; then
  cat >&2 <<'EOF'
pre-commit: CHANGELOG.md must be updated in the same commit.

- Add an entry under [Unreleased] in CHANGELOG.md.
- Stage it: git add CHANGELOG.md
EOF
  exit 1
fi

if [[ "$other_count" -eq 0 ]]; then
  echo "pre-commit: refusing changelog-only commit; commit the actual change together with CHANGELOG.md." >&2
  exit 1
fi

if [[ "${DITTO_LLM_ALLOW_CHANGELOG_RELEASE_EDIT:-}" != "1" ]]; then
  head_changelog="$(git show HEAD:CHANGELOG.md 2>/dev/null || true)"
  index_changelog="$(git show :CHANGELOG.md 2>/dev/null || true)"

  if [[ -n "${head_changelog}" && -n "${index_changelog}" ]]; then
    head_released="$(printf '%s\n' "${head_changelog}" | awk 'BEGIN{s=0} /^## \\[[0-9]/{s=1} s{print}')"
    index_released="$(printf '%s\n' "${index_changelog}" | awk 'BEGIN{s=0} /^## \\[[0-9]/{s=1} s{print}')"

    if [[ "${head_released}" != "${index_released}" ]]; then
      cat >&2 <<'EOF'
pre-commit: refusing to modify released CHANGELOG sections.

Only edit entries under [Unreleased]. Released version sections (e.g. [0.x.y]) are immutable.

If you are cutting a release and intentionally updating versioned sections, re-run with:
  DITTO_LLM_ALLOW_CHANGELOG_RELEASE_EDIT=1 git commit ...
EOF
      exit 1
    fi
  fi
fi

max_rs_lines="${DITTO_MAX_RS_LINES:-1000}"
offenders=()

# Only enforce the line limit on staged Rust changes, so the repository can
# gradually pay down existing large files.
staged_rs_files="$(git diff --cached --name-only --diff-filter=ACMR || true)"
while IFS= read -r path; do
  [[ -z "$path" ]] && continue
  [[ "$path" == *.rs ]] || continue
  lines="$(git show ":$path" 2>/dev/null | awk 'END{print NR}')"
  if [[ "${lines:-0}" -gt "$max_rs_lines" ]]; then
    offenders+=("$path ($lines)")
  fi
done <<<"$staged_rs_files"

if [[ "${#offenders[@]}" -gt 0 ]]; then
  cat >&2 <<EOF
pre-commit: refusing to commit oversized Rust files.

一个良好的代码仓库不应该有超过 ${max_rs_lines} 行的 Rust 文件，这意味着复杂度过度或没有良好的领域分割；请拆分模块，否则禁止提交。

以下 Rust 文件超过 ${max_rs_lines} 行：
$(printf '  - %s\n' "${offenders[@]}")

如果你确实需要临时放宽限制，可设置：
  DITTO_MAX_RS_LINES=<N> git commit ...
EOF
  exit 1
fi

# Refuse newly introduced ignored async results in gateway runtime paths.
# Use an explicit handling branch or an inline allow marker when intentional:
#   // commit-check: allow-ignored-await
ignored_await_offenders=()
current_file=""
while IFS= read -r line; do
  if [[ "$line" == "+++ b/"* ]]; then
    current_file="${line#+++ b/}"
    continue
  fi
  [[ -z "$current_file" ]] && continue
  if [[ "$current_file" != src/gateway/* && "$current_file" != src/bin/ditto_gateway/* ]]; then
    continue
  fi
  if [[ "$line" == +* ]] && [[ "$line" != "+++"* ]]; then
    code="${line#+}"
    if [[ "$code" =~ let[[:space:]]+_[[:space:]]*=.*\.await([[:space:]]*;)?[[:space:]]*$ ]] &&
      [[ "$code" != *"commit-check: allow-ignored-await"* ]]; then
      ignored_await_offenders+=("$current_file: $code")
    fi
  fi
done < <(git diff --cached -U0 -- '*.rs')

if [[ "${#ignored_await_offenders[@]}" -gt 0 ]]; then
  cat >&2 <<EOF
pre-commit: refusing ignored async results in gateway runtime code.

请不要使用 \`let _ = foo().await\` 吞掉错误；请显式处理 Err（日志/映射/传播）。
如确有必要，请在该行添加注释：
  // commit-check: allow-ignored-await

Offenders:
$(printf '  - %s\n' "${ignored_await_offenders[@]}")
EOF
  exit 1
fi

if [[ ! -f "$repo_root/Cargo.toml" ]]; then
  echo "pre-commit: no Cargo manifest found; skipping rust fmt/check." >&2
  exit 0
fi

echo "pre-commit: running Rust gates in $repo_root" >&2

(
  cd "$repo_root"
  cargo fmt -p ditto-llm -- --check
  cargo check -p ditto-llm --all-targets
  cargo clippy -p ditto-llm --all-targets -- -D warnings
)

needs_gateway_regression=0
while IFS= read -r path; do
  [[ -z "$path" ]] && continue
  if [[ "$path" == src/gateway/* || "$path" == src/bin/ditto_gateway/* || "$path" == tests/gateway* ]]; then
    needs_gateway_regression=1
    break
  fi
done <<<"$staged_non_deleted_files"

if [[ "$needs_gateway_regression" -eq 1 ]]; then
  echo "pre-commit: running gateway regression checks" >&2
  (
    cd "$repo_root"
    cargo test -p ditto-llm --features gateway prepare_handle_request_reserves_budget_until_completed_or_rolled_back -- --nocapture
    cargo test -p ditto-llm --features "gateway gateway-proxy-cache" --test gateway_openai_proxy openai_compat_proxy_cache_varies_by_semantic_request_headers -- --nocapture
  )
fi
